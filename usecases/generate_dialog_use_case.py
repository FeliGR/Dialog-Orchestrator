"""
Generate Dialog Use Case Module

This module implements the use case for generating a dialog response by retrieving personality data
from the Persona Engine and combining it with the user's input message. The use case acts as an
it bridges controllers and external services to compose prompts and invoke the LLM
composition and LLM communication, while enforcing domain rules.
"""

from adapters.loggers.logger_adapter import app_logger
from core.domain.dialog_model import BotResponse
from core.interfaces.use_case_interfaces import IGenerateDialogUseCase
from core.services.dialog_domain_service import DialogDomainService


class GenerateDialogUseCase(IGenerateDialogUseCase):
    """
    Use case implementation for generating dialog responses.

    This class implements the IGenerateDialogUseCase interface, providing the business logic to:
      1. Retrieve personality data using the persona client.
      2. Compose a prompt that integrates personality data with the user's input message.
      3. Call the GPT client to generate a dialog response.
    """

    def __init__(self, persona_client, gpt_client):
        """
        Initialize the use case with the required clients.

        Args:
            persona_client (IPersonaClient): Client for retrieving personality data.
            gpt_client (IGPTAdapter): Client for communicating with the language model (LLM).

        Raises:
            ValueError: If either client is None.
        """
        if not persona_client or not gpt_client:
            app_logger.error("Both persona_client and gpt_client must be provided")
            raise ValueError("Both persona_client and gpt_client are required")
        self.persona_client = persona_client
        self.gpt_client = gpt_client
        self.dialog_service = DialogDomainService()

    def execute(self, user_id: str, user_text: str) -> BotResponse:
        """
        Execute the use case to generate a dialog response.

        Args:
            user_id (str): The unique identifier for the user.
            user_text (str): The input message from the user.

        Returns:
            BotResponse: The dialog response generated by the language model.

        Raises:
            ValueError: If inputs are invalid or personality data is not found.
        """
        if not user_id or not isinstance(user_id, str):
            app_logger.error("Invalid user_id provided: %r", user_id)
            raise ValueError("User ID must be a non-empty string")
        if not user_text or not isinstance(user_text, str):
            app_logger.error("Invalid user_text provided: %r", user_text)
            raise ValueError("User text must be a non-empty string")

        app_logger.debug("Retrieving personality data for user: %s", user_id)
        persona_response = self.persona_client.get_persona(user_id)
        if not persona_response or persona_response.get("status") != "success":
            app_logger.error("No personality data found for user_id: %s", user_id)
            raise ValueError(f"No personality data found for user '{user_id}'")

        persona_data = persona_response.get("data", {})
        valid_traits = {
            "agreeableness",
            "conscientiousness",
            "extraversion",
            "neuroticism",
            "openness",
        }
        filtered_persona = {k: v for k, v in persona_data.items() if k in valid_traits}

        if not filtered_persona:
            app_logger.error(
                "No valid personality traits found for user_id: %s", user_id
            )
            raise ValueError(f"No valid personality traits found for user '{user_id}'")
        app_logger.debug("Filtered personality data: %s", filtered_persona)

        app_logger.debug("Composing prompt for user_id: %s", user_id)
        prompt = self.dialog_service.compose_prompt(filtered_persona, user_text)

        app_logger.debug("Calling GPT client to generate response")
        bot_response = self.gpt_client.generate_text(prompt)
        app_logger.info("Dialog generated successfully for user_id: %s", user_id)
        return bot_response
